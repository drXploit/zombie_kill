<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_horde</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create a group of enemies
global.instances++;

//
feature = false;    // for testing
first = -1;         // the first "alive" instance index number

horde_max = 10;                 // max group size
horde_min = 3;                  // minimum group size
horde_radius = 50;              // wouldn't go smaller
horde_direction = 0;            // so they eventually go in the same dir
horde_speed = 1.8;              // group speed
horde_aggressive = false;       // if one gets aggressive, they all do
horde_effect = 0;               // blinking effect under them
horde_effect_size = 0.1;        // size of effect
horde_effect_color = c_dkgray;  // non-aggro effect color
horde_effect_color_mad = c_red; // aggro effect color

horde_amount = irandom_range(horde_min,horde_max);  // random horde spawn count

if ((obj_spawn_control.enemies + horde_amount) &gt; obj_spawn_control.max_enemies)
{
    horde_amount = obj_spawn_control.enemies - obj_spawn_control.max_enemies;
    if (horde_amount &gt;= horde_max)
        horde_amount = horde_max;
}
if (horde_amount &lt;= 0) instance_destroy();

for (i = 0;i &lt; horde_amount; i++)
{
    horde[i] = instance_create(x, y, obj_enemy);
    do
    {
        horde[i].x = x + random_range(-horde_radius,horde_radius);
        horde[i].y = y + random_range(-horde_radius,horde_radius);
        with (horde[i])
        {
            collision = place_meeting(x, y, obj_wall_collision);
        }
    }
    until horde[i].collision = 0
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy
global.instances--;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Step and update code for the horde

var alive = 0;
var cntAggro = 0;


if (horde_effect &gt;= room_speed/5)
{
    for (i=0;i&lt;horde_amount;i++) // cycle through entire list
    {
      if (horde[i] != -1)
      {
            if (instance_exists(horde[i]))
            {
                alive++;
                if (alive == 1)
                {
                    first = i;
                    x = horde[first].x;
                    y = horde[first].y;
                    direction = horde[first].direction;
                    speed = horde[first].speed;
                    //horde[first].enemy_speed = 1.8;
                }
// HORDE NICE       *************************************************************************************
                if (!horde_aggressive)
                {
// HORDE NICE   -   HORDE[i] ALERTED
                    if (horde[i].alerted)
                    {
                        horde_aggressive = true;
                        horde_direction = point_direction(horde[i].x,horde[i].y,obj_player.x,obj_player.y);
                        horde[first].direction = horde_direction;
                    // Alert everyone
                        for (j=0;j&lt;horde_amount;j++)
                        {
                            if (horde[j] != -1)
                            {
                                if (instance_exists(horde[j]))
                                {
                                    cntAggro++;
                                    if (horde[j].state != scr_enemy_distracted)
                                    {  
                                        horde[j].state = scr_enemy_follow;
                                        horde[j].alerted = true;
                                        horde[j].aggro_range = 240 * (horde_amount/3);
//                                        if (horde[j] == horde[first])
                                        if (alive == 1)
                                        {
                                            horde[j].speed = (1.8 * .76);
                                            audio_play_sound(choose(snd_zombie_alive1,snd_zombie_alive2,snd_zombie_alive3,snd_zombie_alive4), 8, false);  // leader makes a sound
                                      //      effect_create_below(ef_ring,horde[j].x,horde[j].y,2,horde_effect_color_mad); // leader makes a bigger ping
                                        }
                                        else
                                        {
                                            horde[j].speed = (1.8 * .75);
                                            horde[j].direction = point_direction(horde[j].x,horde[j].y,obj_player.x,obj_player.y); //horde[first].direction;
                                   //         effect_create_below(ef_ring,horde[j].x,horde[j].y,.5,horde_effect_color_mad); // smaller ping for others
                                        }
                                    }
                                }
                                else
                                    horde[j] = -1;
                            }
                        }
                    }
// HORDE NICE   -   HORDE[i] NOT ALERTED
                    else
                    {       // Don't let friends wander too far
                            if (distance_to_point(horde[i].x,horde[i].y) &gt; 140)
                            {
                                    horde[i].direction = point_direction(horde[i].x,horde[i].y,x,y);
                            }
                     //       else
                 //           {
                    //            if (alive &gt; 1) effect_create_below(ef_star, horde[i].x, horde[i].y, 0.2, make_color_rgb(211,227,151));//green/yellow
                    //            else effect_create_below(ef_star, horde[i].x, horde[i].y, 0.5, c_yellow);//make_color_rgb(100,124,100));//'unreturned'zombie color
                      //      }
                    }
                }
// HORDE AGGRESSIVE *************************************************************************************
                else
                {                   
                        if (horde[i].alerted)
                        {
                            cntAggro++;
                         //   effect_create_below(ef_ring,horde[i].x,horde[i].y,.5,horde_effect_color_mad);
                            if (distance_to_point(horde[i].x,horde[i].y) &gt; 300)
                            {
                                if (!collision_line(horde[i].x,horde[i].y,x,y,obj_wall_collision,false,true))
                                    horde[i].direction = point_direction(horde[i].x, horde[i].y, x, y);
                                else
                                {
                  //                  effect_create_above(ef_smokeup,horde[i].x,horde[i].y,1,c_green);
                                    horde[i].x = x;
                                    horde[i].y = y;
                          //          effect_create_above(ef_smoke,x,y,1,c_green);
                                }
                            }       
                        }
                    //    else
                         //   effect_create_below(ef_ring, horde[i].x, horde[i].y, 0.5, c_gray);
                }
            }
            else horde[i] = -1;
        }
    }
    
    if (alive == 0) // no enemies = destroy instance
    {
    //    effect_create_below(ef_explosion,x,y,horde_amount/2,c_green);
        instance_destroy();
    }
    // group aggressive, only one alive, and not alerted, so make group not alerted
    if (horde_aggressive) &amp;&amp; (alive == 1)&amp;&amp; (!horde[first].alerted)
        horde_aggressive = false;

    // more than 1 enemy so figure out if less than half is aggressive, if not set group to not aggressive
    if (horde_aggressive) &amp;&amp; (alive &gt; 1) &amp;&amp; (cntAggro &lt; (alive/2))
        horde_aggressive = false;
        
    horde_effect = 0;
}
else 
{
    horde_effect++;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean instance

instance_destroy();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean instance

instance_destroy();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw self

/// Dont draw self!


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
